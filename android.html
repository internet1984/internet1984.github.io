<!DOCTYPE HTML>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="Keywords" content="blog"/>
    <meta name="Description" content="blog"/>
    <title>Simple</title>
    <link rel="shortcut icon" href="/static/favicon.png"/>
    <link rel="stylesheet" type="text/css" href="/main.css" />
</head>
<body>
<div class="main">
    <div class="header">
    	<ul id="pages">
            <li><a href="/">home</a></li>
            <li><a href="/#/tags">tags</a></li>
            <li><a href="/#/archive">archive</a></li>
    	</ul>
    </div>
	<div class="wrap-header">
			<h1>
            <a href="/" id="title"></a>
			</h1>
	</div>
<div id="md" style="display: none;">
<!-- markdown -->
最近在浏览某篇有关事件流的文章时，里面提到了数据的流处理，兴趣来了，就想看看能否在Android端实现一个。

      根据文章的介绍，将每次数据的变更事件，像是插入，删除或者更新等，记为一个不可变的事件，让数据在事件中流淌，而不是对数据库进行破坏性的写入，也就是说，直接读取数据的聚合结果就能获取最好的性能。

      事件流可以完成下面的工作：

1.获取所有的原始事件，可能需要进行转换，然后将它们加载到一个大型的数据仓库中供分析人员使用；

2.更新全文搜索索引，使用户可以搜索最新的数据；
3.更新缓存，使系统可以从快速缓存中读取数据，并保证缓存中的数据是最新的；
4.通过对事件流进行处理创建一个新的事件流，然后将后者作为另一个系统的输入。
     可能带来的好处如下：
1.松耦合：数据读写使用不同的数据库模式，读取的数据经由写入的数据转换而来，应用程序不同部分间的耦合度降低了；
2.读写性能：规范化（写入快）和非规范化（读取快）的争论源于数据读写使用同一个模式的假设，如果数据读写使用不同的数据库模式，读写速度都会得到提升；
3.扩展性：因为事件流是一种简单的抽象，而且允许开发人员将应用程序分解成流的生产者和消费者，所以容易跨机器并行和扩展；
4.灵活性：原始事件简单明确，模式迁移不会造成多大影响，而向用户展示数据要复杂得多，但如果有一个转换过程可以实现从原始事件到缓存内容的转换，那么当需要新的用户界面时，只需要使用新的逻辑构建新的缓存；
5.错误场景：原始事件是不变的事实，如果系统出现问题，那么开发人员总是可以用相同的顺序将事件重放。
 
      如果是这样的设计， 编写查询或者规则来匹配满足特定模式的事件，还要在流上进行全文搜索，在流上事先注册一个查询，当有事件匹配查询时发送通知。
由此衍生出几个概念：
1.响应式：主要是将事件流提供给用户界面使用；
2.变更数据捕获：按照我们熟悉的方式使用数据库，但要将任何插入，更新和删除操作抽取到一个数据变更事件流中。
      初步的实现已经出来了，大概的实现如下：
1.创建数据库和表
      在assets文件夹下创建database.xml文件，里面配置数据库的名字，版本号和数据库的表：
复制代码
   <?xml version="1.0" encoding="utf-8"?>
      <database>
          <!-- 数据库名称 -->
          <dbname value="zwb.db"></dbname>

          <!-- 数据库版本 -->
          <version value="1"></version>

          <!-- 数据库表 -->
          <list>
              <mapping class="com.zwb.args.dbpratice.model.Status"></mapping>
              <mapping class="com.zwb.args.dbpratice.model.User"></mapping>
          </list>
      </database>
复制代码
     然后初始化DatabaseCache：

DatabaseCache cache = DatabaseCache.getInstance(this);
    该操作应该是在Application中声明，因为该动作涉及到数据库和表的创建。

2.基本使用

   声明一个model类，继承自BaseTable:

复制代码
             @Table(table = "status")
             public class Status extends BaseTable {
                 @Column
                 private String name;
                 @Column
                 private String statusId;

                 public void setName(String name) {
                     this.name = name;
                 }

                 public String getName() {
                     return name;
                 }

                 public void setStatusId(String id) {
                     this.statusId = id;
                 }

                 public String getStatusId() {
                     return statusId;
                 }
             }
复制代码
     其中，@Table声明的是该model对应的表的名字，@Column声明的是该字段对应的数据库中的类型。如果该字段的类型和数据库中的类型不一致，可以通过@ColumnType来指定类型。

3.数据插入

 Status status = new Status();
 status.setName("转发");
 status.setStatusId("01");
 InsertEvent insertStatusEvent = new InsertEvent();
 insertStatusEvent.to(Status.class).insert(status);
4.数据更新

 UpdateEvent updateEvent = new UpdateEvent();
 updateEvent.to(Status.class).where("id", "01").update("name", "你好");
5.数据查询

List<Status> statusList = cache.from(Status.class).where("statusId", "01").find();
这样就是查询Status表中的statusId为01的所有记录。当然，也可以查询所有数据：
List<Status> statusList = cache.from(Status.class).findAll();
6.数据读取

DatabaseCache cache = DatabaseCache.getInstance(this);
List<Status> statusList =  cache.readFromDb(Status.class);
   该操作应该在Application中执行，然后执行相应的数据插入：

 for(Status status : statusList){
      InsertEvent insertEvent = new InsertEvent();
      insertEvent.to(Status.class).insert(status);
}
 这样数据就会从数据库转移到事件流中。

7.数据存储
DatabaseCache cache = DatabaseCache.getInstance(this);
cache.insertToDb(Status.class);
 这样就会将和Status有关的数据插入到数据库中。

8.数据删除
DeleteEvent deleteEvent = new DeleteEvent();
deleteEvent.to(Status.class).where("id", "01").delete();
  这样就是删除id为01的数据。

  如果是删除某个集合的全部数据，则是:
复制代码
        List<Status> statuses = new ArrayList<Status>();
        for(int i = 0; i < 10; i++){
              Status status = new Status();
              status.setName("你好");
              status.setId("01");
              statuses.add(status);
        }
        deleteEvent.to(Status.class).deleteAll(statuses);
复制代码
  如果是删除表的全部数据：
deleteEvent.to(Status.class).deleteAll();
      这是目前的实现，后面会有时间讲解一下实现的过程，具体的项目地址放在github上：https://github.com/wenjiang/EventStreamDB，有兴趣可以上去看看，顺便给个星星。
<!-- markdown end -->
</div>
<div class="entry" id="main">
<!-- content -->
<p>最近在浏览某篇有关事件流的文章时，里面提到了数据的流处理，兴趣来了，就想看看能否在Android端实现一个。</p>

<pre><code>  根据文章的介绍，将每次数据的变更事件，像是插入，删除或者更新等，记为一个不可变的事件，让数据在事件中流淌，而不是对数据库进行破坏性的写入，也就是说，直接读取数据的聚合结果就能获取最好的性能。

  事件流可以完成下面的工作：
</code></pre>

<p>1.获取所有的原始事件，可能需要进行转换，然后将它们加载到一个大型的数据仓库中供分析人员使用；</p>

<p>2.更新全文搜索索引，使用户可以搜索最新的数据；
3.更新缓存，使系统可以从快速缓存中读取数据，并保证缓存中的数据是最新的；
4.通过对事件流进行处理创建一个新的事件流，然后将后者作为另一个系统的输入。
     可能带来的好处如下：
1.松耦合：数据读写使用不同的数据库模式，读取的数据经由写入的数据转换而来，应用程序不同部分间的耦合度降低了；
2.读写性能：规范化（写入快）和非规范化（读取快）的争论源于数据读写使用同一个模式的假设，如果数据读写使用不同的数据库模式，读写速度都会得到提升；
3.扩展性：因为事件流是一种简单的抽象，而且允许开发人员将应用程序分解成流的生产者和消费者，所以容易跨机器并行和扩展；
4.灵活性：原始事件简单明确，模式迁移不会造成多大影响，而向用户展示数据要复杂得多，但如果有一个转换过程可以实现从原始事件到缓存内容的转换，那么当需要新的用户界面时，只需要使用新的逻辑构建新的缓存；
5.错误场景：原始事件是不变的事实，如果系统出现问题，那么开发人员总是可以用相同的顺序将事件重放。</p>

<pre><code>  如果是这样的设计， 编写查询或者规则来匹配满足特定模式的事件，还要在流上进行全文搜索，在流上事先注册一个查询，当有事件匹配查询时发送通知。
</code></pre>

由此衍生出几个概念：
1.响应式：主要是将事件流提供给用户界面使用；
2.变更数据捕获：按照我们熟悉的方式使用数据库，但要将任何插入，更新和删除操作抽取到一个数据变更事件流中。
      初步的实现已经出来了，大概的实现如下：
1.创建数据库和表
      在assets文件夹下创建database.xml文件，里面配置数据库的名字，版本号和数据库的表：
复制代码
   <!--?xml version="1.0" encoding="utf-8"?-->

<pre><code>  &lt;database&gt;
      &lt;!-- 数据库名称 --&gt;
      &lt;dbname value="zwb.db"&gt;&lt;/dbname&gt;

      &lt;!-- 数据库版本 --&gt;
      &lt;version value="1"&gt;&lt;/version&gt;

      &lt;!-- 数据库表 --&gt;
      &lt;list&gt;
          &lt;mapping class="com.zwb.args.dbpratice.model.Status"&gt;&lt;/mapping&gt;
          &lt;mapping class="com.zwb.args.dbpratice.model.User"&gt;&lt;/mapping&gt;
      &lt;/list&gt;
  &lt;/database&gt;
</code></pre>

<p>复制代码
     然后初始化DatabaseCache：</p>

<p>DatabaseCache cache = DatabaseCache.getInstance(this);
    该操作应该是在Application中声明，因为该动作涉及到数据库和表的创建。</p>

<p>2.基本使用</p>

<p>声明一个model类，继承自BaseTable:</p>

<p>复制代码
             @Table(table = "status")
             public class Status extends BaseTable {
                 @Column
                 private String name;
                 @Column
                 private String statusId;</p>

<pre><code>             public void setName(String name) {
                 this.name = name;
             }

             public String getName() {
                 return name;
             }

             public void setStatusId(String id) {
                 this.statusId = id;
             }

             public String getStatusId() {
                 return statusId;
             }
         }
</code></pre>

<p>复制代码
     其中，@Table声明的是该model对应的表的名字，@Column声明的是该字段对应的数据库中的类型。如果该字段的类型和数据库中的类型不一致，可以通过@ColumnType来指定类型。</p>

<p>3.数据插入</p>

<p>Status status = new Status();
 status.setName("转发");
 status.setStatusId("01");
 InsertEvent insertStatusEvent = new InsertEvent();
 insertStatusEvent.to(Status.class).insert(status);
4.数据更新</p>

<p>UpdateEvent updateEvent = new UpdateEvent();
 updateEvent.to(Status.class).where("id", "01").update("name", "你好");
5.数据查询</p>

<p>List<status> statusList = cache.from(Status.class).where("statusId", "01").find();
这样就是查询Status表中的statusId为01的所有记录。当然，也可以查询所有数据：
List<status> statusList = cache.from(Status.class).findAll();
6.数据读取</status></status></p>

<p>DatabaseCache cache = DatabaseCache.getInstance(this);
List<status> statusList =  cache.readFromDb(Status.class);
   该操作应该在Application中执行，然后执行相应的数据插入：</status></p>

<p>for(Status status : statusList){
      InsertEvent insertEvent = new InsertEvent();
      insertEvent.to(Status.class).insert(status);
}
 这样数据就会从数据库转移到事件流中。</p>

<p>7.数据存储
DatabaseCache cache = DatabaseCache.getInstance(this);
cache.insertToDb(Status.class);
 这样就会将和Status有关的数据插入到数据库中。</p>

<p>8.数据删除
DeleteEvent deleteEvent = new DeleteEvent();
deleteEvent.to(Status.class).where("id", "01").delete();
  这样就是删除id为01的数据。</p>

<p>如果是删除某个集合的全部数据，则是:
复制代码
        List<status> statuses = new ArrayList<status>();
        for(int i = 0; i &lt; 10; i++){
              Status status = new Status();
              status.setName("你好");
              status.setId("01");
              statuses.add(status);
        }
        deleteEvent.to(Status.class).deleteAll(statuses);
复制代码
  如果是删除表的全部数据：
deleteEvent.to(Status.class).deleteAll();
      这是目前的实现，后面会有时间讲解一下实现的过程，具体的项目地址放在github上：https://github.com/wenjiang/EventStreamDB，有兴趣可以上去看看，顺便给个星星。</status></status></p>
<!-- content end -->
</div>
<br>
<br>
    <div id="disqus_thread"></div>
	<div class="footer">
		<p>© Copyright 2014 by isnowfy, Designed by isnowfy</p>
	</div>
</div>
<script src="main.js"></script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ["\\(", "\\)"]], processEscapes: true}});
</script>
<script id="content" type="text/mustache">
    <h1>{{title}}</h1>
    <div class="tag">
    {{date}}
    {{#tags}}
    <a href="/#/tag/{{name}}">#{{name}}</a>
    {{/tags}}
    </div>
</script>
<script id="pagesTemplate" type="text/mustache">
    {{#pages}}
    <li>
        <a href="{{path}}">{{title}}</a>
    </li>
    {{/pages}}
</script>
<script>
$(document).ready(function() {
    $.ajax({
        url: "main.json",
        type: "GET",
        dataType: "json",
        success: function(data) {
            $("#title").html(data.name);
            var pages = [];
            //path
            var path = "android.html";
            //path end
            var now = 0;
            for (var i = 0; i < data.pages.length; ++i)
                if (path == data.pages[i].path) {
                    now = i;
                    pages.push({"select": true, "path": data.pages[i].path, "title": data.pages[i].title});
                }
                else {
                    pages.push({"select": false, "path": data.pages[i].path, "title": data.pages[i].title});
                }
            var pagesTemplate = Hogan.compile($("#pagesTemplate").html());
            var pagesHtml = pagesTemplate.render({"pages": pages});
            $("#pages").append(pagesHtml);
            var post = data.pages[now];
            var tmp = post.tags.split(" ");
            var tags = [];
            for (var i = 0; i < tmp.length; ++i)
                if (tmp[i].length > 0)
                    tags.push({"name": tmp[i]});
            var contentTemplate = Hogan.compile($("#content").html());
            var contentHtml = contentTemplate.render({"title": post.title, "tags": tags, "date": post.date});
            $("#main").prepend(contentHtml);
            if (data.disqus_shortname.length > 0) {
                var disqus_shortname = data.disqus_shortname;
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            }
        }
    });
});
</script>
</body>
</html>
